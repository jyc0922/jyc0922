### 웹 요청과 응답의 본질 이해하기

### HTTP의 request / response 구조
💡HTTP (Hypertext Transfer Protocol)는 클라이언트와 서버간의 통신을 위한 프로토콜로, 기본적으로 **request(요청)**과 **response(응답)** 구조로 동작합니다. 웹에서 정보를 주고받는 거의 모든 과정이 이 **요청/응답** 쌍으로 이루어 집니다.

1. HTTP Request(HTTP 요청)
> 🔚 클라이언트(일반적으로 웹 브라우저)가 서버에 특정 리소스나 작업을 요청할 때 HTTP 요청을 보냅니다. HTTP 요청은 크게 **Request Line**, **Request Headers**, **Request Body** 세 부분으로 구성됩니다.
* (1) 요청 라인(Request Line):
  * 메서드(Method): 서버가 수행해야 할 동작을 지정합니다. 가장 일반적인 메서드는 다음과 같습니다.

  |메서드  |  동작 |
  |-------|-------|
  |GET    |특정 리소소를 가져올 때 사용(예: 페이지, 이미지)  |
  |POST   |서버에 데이터를 제출할 때 사용(예: 로그인 폼 제출, 게시글 작성)|
  |PUT    |특정 리소스를 생성하거나 업데이트할 때 사용|
  |DELETE |특정 리소스를 삭제할 때 사용|
  |HEAD   |GET과 동일하지만 응답 본문 없이 헤더만 받음|
  |OPTION |서버가 지원하는 메서드를 질의할 때 사용|

  * 요청 URI (Request URI / Path): 요청하는 리소스의 경로를 나타냅니다. (예: /index.html, /api/users)
  * HTTP버전(HTTP Version): 클라이언트가 사용하는 HTTP프로토콜 버전입니다. (예: HTTP/1.1, HTTP/2.0)
    > 예시: **GET/index.html HTTP/1.1**

* (2) 요청 헤더(Request Headers):
  * 요청에 대한 추가 정보나 메타데이터를 포함합니다. 각 헤더는 **이름:값** 형태로 구성됩니다.

  |이름    |값       |
  |-------|---------|
  |Host   |요청하는 서버의 도메인 이름과 포트 번호. (필수)|
  |User-Agent|요청을 보내는 클라이언트(브라우저, OS등) 정보|
  |Accept |클라이언트가 처리할 수 있는 미디어 타입(MIME 타입)을 명시|
  |Accept-Language|클라이언트가 선호하는 언어|
  |Cookie|서버가 이전에 설정한 쿠키 정보|
  |Content-Type|요청 본문에 포함된 데이터의 미디어 타입(POST, PUT 요청 시 주로 사용)|
  |Content-Length|요청 본문의 길이 (POST, PUT 요청 시 주로 사용)|

* (3) 요청 본문(Request Body):
  * **Get** 요청에는 보통 본문이 없습니다. **POST**, **PUT**과 같이 서버에 데이터를 전송해야 할 때 사용됩니다. HTML 폼 데이터, JSON, XML 등의 형태로 데이터를 포함합니다.

2. HTTP Response (HTTP 응답)
> 🔚서버는 클라이언트의 HTTP 요청을 처리한 후 그 결과를 HTTP 응답으로 클라이언트에게 보냅니다. HTTP 응답도 크게 **상태 라인**, **응답 헤더**, **응답 본문** 세 부분으로 구성됩니다.

 * (1) 상태 라인(Status Line):
   * HTTP버전(HTTP Version): 서버가 사용하는 HTTP 프로토콜 버전.
   * 상태 코드: 요청 결과를 나타내는 세 자리 숫자 코드.

   |상태 코드   |요청 결과      |
   |----------|--------------|
   |2xx Success|요청이 성공적으로 처리 됨(예: **200 OK**, **201 Created**)|
   |2xx Redirection|요청을 완료하기 위해 추가적인 동작이 필요함을 의미(예: **301 Moved Permanently**, **302 Found**)|
   |4xx Client Error|클라이언트의 잘못된 요청으로 인해 발생(예: **400 Bad Request**, **401 Unauthorized**, **403 Forbidden**, **404 Not Found**)|
   |5xx Server Error|서버의 문제로 인해 요청 처리 실패(예: **500 Internal Server Error**, **503 Service Unavailable**)|

   * 상태메시지(Reason Phrase): 상태 코드를 설명하는 짧은 테스트
    > **HTTP/1.1/ 200 OK**

 * (2) 응답 헤더(Response Headers):
   * 응답에 대한 추가 정보나 메타데이터를 포함합니다.

   |헤더    |정보           |
   |--------|--------------|
   |Date    |응답이 생성된 날짜와 시간|
   |Server  |응답을 생성한 웹 서버 소프트웨어 정보|
   |Content-Type|응답 본문에 포함된 데이터의 미디어 타입|
   |Content-Length|응답 본문의 길이|
   |Set-Cookie|클라이언트에게 설정하라고 지시하는 쿠키 정보|
   |Cache-Control|캐싱에 대한 지시|
   |Location|리다이렉션(**3xx** 상태 코드)시 이동할 새로운 URI|

 * (3) 응답 본문(Response Body):
   * 서버가 클라이언트에게 전달하는 실제 데이터 입니다.
   * 요청된 HTML 페이지, 이미지, JSON 데이터, XML 등이 여기에 포함됩니다.

⚠️HTTP는 이러한 요청 / 응답 구조를 통해 클라이언트와 서버가 서로 통신하며 웹 상의 다양한 정보를 주고받을수 있도록 합니다. 각 요청과 응답은 필요한 정보를 담은 헤더와 실제 데이터를 담는 본문으로 구성되어 있으며, 이를 통해 효율적이고 체계적인 통신이 가능해집니다.

### Ajax, forward, redirect 차이
💡웹 개발에서 페이지 이동 또는 데이터 통신을 처리하는 방식에는 여러 가지가 있으며, 그중 **AJAX**, **Forward (서버 내부 포워딩)**, **Redirect(클라이언트 리다이렉션)** 는 각각 다른 목적과 동작 방식을 가집니다.

1. AJAX (Asynchronous JavaScript and XML)
* **정의:** 웹 페이지 전체를 새로고침하지 않고도 서버와 비동기적으로 데이터를 교환하고, 웹 페이지의 특정 부분만 업데이트를 할 수 있는 기술입니다. JSON, HTML, 일반 텍스트 등 다양한 형식의 데이터를 주고 받을 수 있습니다.
* **동작 방식:** 
  * (1) 클라이언트(브라우저)에서 JavaScript를 사용하여 비동기 HTTP 요청(XMLHttpRequest 또는 Fetch API등)을 서버로 보냅니다.
  * (2) 서버는 요청을 처리하고, 결과를 응답(주로 JSON, XML, HTML fragment)으로 클라이언트에게 보냅니다.
  * (3) 클라이언트는 응답을 받은 후 JavaScript를 사용하여 페이지의 특정 DOM 요소를 업데이트 합니다. 이 과정에서 전체 페이지는 새로 고침 되지 않습니다.
* **주요특징:**
  * **비동기성:** 요청을 보낸 후 응답을 기다리지 않고 다른 작업을 계속 할 수 없습니다.
  * **부분 업데이트:** 페이지 전체를 새로 고침하지 않고 특정 부분만 업데이트 하여 사용자 경험(UX)을 향상 시킵니다.
  * **URL 변경 없음:** 기본적으로 브라우저의 URL의 변경되지 않습니다. (HTML5 History API를 사용하여 변경 가능하지만, AJAX 자체의 특징은 아닙니다.)
  * **별도의 HTTP 요청:** 클라이언트가 새로운 HTTP 요청을 서버로 보냅니다.
* **장점:**
  * **향상된 사용자 경험:** 페이지 깜빡임 없이 동적인 콘텐츠 업데이트가 가능하여 반응성이 높고 매끄러운 사용자 경험을 제공합니다.
  * **서버 부하 감소 및 대역폭 절약:** 필요한 데이터만 전송하므로 서버 부하와 네트워크 트래픽을 줄일 수 있습니다.
  * **빠른 응답 시간:** 전체 페이지를 로드하지 않으므로 사용자가 체감하는 로딩 속도가 빠릅니다.
* **단점:**
  * **JavaScript 의존성:** JavaScript가 비활성화된 환경에서는 작동하지 않습니다.
  * **SEO(검색 엔진 최적화)문제:** 검색 엔진 크롤러가 동적으로 로드된 콘텐츠를 제대로 인덱싱하지 못 할 수 있습니다.
  * **북마크 및 뒤로가기 문제:** URL이 변경되지 않으므로 특정 상태를 북마크하거나 브라우저의 뒤로가기/ 앞으로가기 버튼을 사용할 때 예상과 다른 동작을 할 수 있습니다.
  * **복잡성 증가:** 클라이언트 측에서 데이터를 처리하고 DOM을 조작하는 로직이 추가되어 개발 복잡성이 증가할 수 있습니다.

2. Forward (서버 내부 포워딩) 
* **정의:** 서버 내부에서 하나의 요청을 다른 서버 측 리소스(다른 서블릿, JSP, 컨트롤러 메섣드 등)로 전달하는 방식입니다. 클라이언트는 이 과정에 대해 알지 못합니다.
* **동작 방식:**
  * (1) 클라이언트가 서버에 첫 번째 요청(Request)을 보냅니다.
  * (2) 서버의 첫 번째 리소스(예: **ServletA**)가 요청을 받은 후, 클라이언트에게 응답을 보내지 않고 해당 요청을 서버 내부의 다른 리소스(예: **ServletB** 또는 **JSP**)로 전달합니다.
  * (3) 두 번째 리소스(**ServletB** 또는 **JSP**)가 최종적으로 요청을 처리하고 클라이언트에게 응답(Response)을 보냅니다.
* **주요 특징:**
  * **서버 내부 처리:** 클라이언트에게는 한 번의 **요청-응답**처럼 보이며, 브라우저는 중간에 포워딩이 일어났음을 알지 못합니다.
  * **URL 변경 없음:** 브라우저의 주소창 URL은 최초 요청의 URL 그대로 유지됩니다.
  * **Request / Response 객체 공유:** 최초 요청의 **HttpServletReqeust** 와 **HttpServletResponse** 객체가 포위딩되는 리소스에도 그대로 전달됩니다. 따라서 요청 스코프(request scope)의 데이터를 공유할 수 있습니다.
  * **성능:** 네트워크를 통한 추가적인 요청이 없으므로 Redirect보다 빠릅니다.
* **장점:** 
  * **데이터 공유 용이:** 요청 객체가 유지되므로 서블릿 또는 서블릿과 JSP 간 데이터 공유가 쉽습니다.
  * **성능 우수:** 클라이언트와의 추가적인 통신이 없으므로 서버 내부에서 빠르게 처리됩니다.
  * **URL 숨김:** 실제 처리되는 내부 URL을 클라이언트에게 노출하지 않을 수 있습니다.
* **단점:**
  * **새로고침 문제:** POST 요청 후 forward 된 페이지에서 새로 고침을 하면 이전에 전송된 POST 데이터가 다시 전송되어 중복 제출(예: 게시글 중복 등록) 문제가 발생할 수 있습니다.
  * **클라이언트가 URL 변경을 알 수 없음:** 사용자가 페이지의 실제 위치를 알 수 없어 북마크 등의 기능을 사용하기 어렵습니다.
  * **동일 웹 애플리케이션 내에서만 가능:** 다른 웹 애플리케이션이나 외부 URL로는 forward 할 수 없습니다.

3. Redirect (클라이언트 리다이렉션)
* **정의:** 서버가 클라이언트에게 다른 URL로 다시 요청을 보내라고 지시하는 방식입니다. 클라이언트는 서버의 응답을 받아 새로운 URL로 재요청을 보냅니다.
* **동작 방식:**
  * (1) 클라이언트가 서버에 첫 번째 요청(Request)을 보냅니다.
  * (2) 서버의 첫 번째 리소스가 요청을 처리한 후, 클라이언트에게 **3xx**상태 코드(예:**302 Found**)와 함께 **Location** 헤더에 새로운 URL을 담아 응답을 보냅니다.
  * (3) 클라이언트(브라우저)는 이 응답을 받고 **Location** 헤더에 명시된 새로운 URL로 다시 HTTP요청을 보냅니다.
  * (4) 두 번째 요청에 대한 응답을 받아 페이지를 로드합니다.
* **주요특징:**
  * **클라이언트 참여:** 클라이언트(브라우저)가 두 번의 요청을 보내는 과정에 직접 관여합니다.
  * **URL 변경:** 브라우저의 주소창 URL이 새로운 URL로 변경됩니다.
  * **Request / Response 객체 소멸:** 첫 번째 요청의 **HttpServletRequest** 와 **HttpServletResponse** 객체는 소멸되고, 새로운 요청이 발생하므로 새로운 객체가 생성됩니다. 따라서 요청 스코프의 데이터는 유지되지 않습니다.
  * **성능:** 두 번의 HTTP**요청-응답**이 발생하므로 Forward보다 느립니다.
* **장점:**
  * **새로고침 문제 해결:** POST 요청 후 redirect하면 브라우저는 새로운 GET 요청을 보내므로 새로고침 시 중복 제출 문제가 발생하지 않습니다. (Post / Redirect / Get (PRG)패턴)
  * **URL 변경:** 사용자에게 실제 접근한 URL을 명확하게 보여줄 수 있습니다.
  * **외부 URL로 이동 가능:** 동일한 웹 애플리케이션뿐만 아니라 다른 서버, 다른 도메인의 URL로도 리다이렉트할 수 있습니다.
* **단점:**
  * **성능 저하:** 두 번의 **요청-응답**이 발생하므로 Forward보다 느립니다.
  * **데이터 전달 어려움:** 요청 객체가 유지되지 않아 이전 요청의 데이터를 직접 전달하기 어렵습니다.

### 📌AJAX, Forward, Redirect 비교 표

|특성    |AJAX(Asynchronous JavaScript and XML) | Forward(서버 내부 포워딩) | Redirect(클라이언트 리다이렉션) |
|-------|----------|----------|---------|
|주체   |클라이언트(JavaScript) | 서버(Web Container) | 서버(응답) -> 클라이언트 (재요청)|
|URL 변경| 기본적으로 없음(History API 사용 시 가능) |없음(최오 요청 URL 유지) | 있음 (새로운 URL로 변경) |
|HTTP 요청 수|1회 (비동기 요청) + 필요에 따라 추가 요청|1회 (클라이언트는 한 번만 요청)|2회 (클라이언트가 첫 응답 후 재요청)|
|Request/Response 객체 공유|새로운 요청이므로 공유 안 됨(별도의 데이터 통신)|공유 됨(최초 요청 객체 유지)|공유 안 됨(새로운 요청이므로 새로운 객체 생성)|
|데이터 전달|응답으로 받은 데이터를 JavaScript로 파싱 및 처리|Request 객체 속성(**setAttribute()**)을 통해 전달|쿼리 파라미터, 세션 등을 통해 간접적으로 전달|
|속도|빠름 (부분 업데이트), 비동기적|빠름 (서버 내부 처리)|느림 (두 번의 네트워크 요청)|
|새로고침 문제|해당 없음(부분 업데이트이므로 전체 새로고침 개념과 다름)| 발생 가능 (POST 후 새로고침시 중복 제출)|해결됨 (PRG 패턴)|
|사용 범위|웹 페이지의 특정 영역 업데이트, 비동기 데이터 통신|동일 웹 애플리케이션 내의 다른 서버 리소스|동일/다른 웹 애플리케이션, 외부 URL|
|사용자 경험|매끄럽고 동적인 경험|자연스러운 페이지 이동 (사용자 인지 어려움)|새로운 페이지로 이동 (사용자 인지 가능)|

* **AJAX:** 웹 페이지의 특정 부분만 동적으로 업데이트하여 **사용자 경험을 향상** 시키고자 할 때 사용합니다. 페이지 전체 새로고침 없이 빠른 피드백이 필요한 경우에 적합합니다.
* **Forward:** **서버 내부에서 제어를 넘기고 싶을 떄**, 즉 클라이언트에게 URL 변경을 알리지 않고 요청 데이터를 다음 리소스에 그대로 전달하여 처리를 위임하고 싶을 때 사용합니다. 주로 MVC 패턴에서 컨트롤러가 뷰(JSP)로 데이터를 전달하며 페이지를 보여줄 때 많이 쓰입니다.
* **Redirect:** **새로운 요청을 발생시켜 URL을 변경**하고 싶을 때, 특히 POST 요청 후 **중복 제출 방지**를 하거나, 외부/ 다른 웹 애플리케이션으로 이동시킬 때 사용합니다.