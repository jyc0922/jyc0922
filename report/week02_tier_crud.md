### 3계층 구조와 CRUD 작동 흐름 조사.

### 3계층 구조(Three-tier architecture)

3계층 구조는 하기와 같이 나뉩니다.
1. 프레젠테이션 계층 (Presentation)
2. 비즈니스 로직 계층 (Business Logic Layer)
3. 데이터 접근 계층 (Data Access Layer)

각 계층의 역할은 다음과 같습니다.
1. **Presentation**: 웹 계층(Web Layer), 사용자 인터페이스 계층(User Interface Layer)
* 사용자에게 정보를 표시하고, 사용자로부터 입력을 받아 처리하는 사용자와 웹 서비스간의 상호작용을 담당합니다.
* 사용자 인터페이스 제공, 사용자 입력 처리, 데이터 시각화, 세션 관리, 주요 기술
2. **Business Logic**: 애플리케이션 계층(Application Layer), 서비스 계층(Service Layer), 도메인 계층(Domain Layer)
* 애플리케이션의 핵심 비즈니스 규칙과 프로세스를 정의하고 실행하고, 프레젠테이션 계층과 데이터 접근 계층 사이에서 중간 다리 역할을 합니다.
* 비즈니스 규칙 적용, 데이터 처리 및 가공, 트랜잭션 관리, 권한 및 보안, 데이터 접근 계층 호출, 주요 기술
3. **Data Access(DAL)**: 영속성 계층(Persistence Layer), 저장소 계층(Repository Layer)
* 데이터베이스 또는 다른 영구 저장소와 통신하여 데이터를 읽고 쓰는 역할을 하고, 비즈니스 로직 계층이 특정 데이터 저장 기술에 의존하지 않도록 추상화합니다.
* 데이터베이스 연결 관리, CRUD 작업 수행, SQL 쿼리 또는 ORM(Object-Relational Mapping)사용, 데이터베이스 관련 예외 처리

3계층 구조의 장점:
* 분리된 관심사: 각 계층이 독립적인 역할을 수행하므로, 한 계층의 변경이 다른 계층에 미치는 여향을 최소화할 수 있습니다.
* 재사용성: 각 계층의 모듈을 독립적으로 개발하고, 필요에 따라 다른 애플리케이션에서 재사용할 수 있습니다.
* 유지보수 용이성: 각 계층이 명확히 분리되어 있어, 문제 발생 시 해당 계층만 집중적으로 디버깅하고 수정할 수 있습니다.
* 확장성: 특정 계층에 부하가 집중될 경우, 해당 계층만 독립적으로 확장 할 수 있어 전체 시스템의 확장성을 높일 수 있습니다.
* 병렬 개발: 여러 개발자가 각 계층을 동시에 개발할 수 있어 개발 속도를 향상시킬 수 있습니다.
* 테스트 용이성: 각 계층을 독립적으로 테스트할 수 있어 단위 테스트 및 통합 테스트를 용이하게 합니다.

### CRUD(Create, Read, Update, Delete) 작동흐름

CURD 작동: **Create(생성)** → **Read(조회)** → **Update(수정)** → **Delete(삭제)**
* CRUD는 데이터가 생성되고, 조회되고, 수정되고, 삭제되는 기본적인 데이터 조작 작업의 의미하여, 3계층 구조는 이러한 CRUD 작업을 효율적으로 분리하고 처리하기 위한 아키텍처입니다.
CURD 작동예시:
* 1. 사용자(Presentation)가 게시글 수정 화면에서 내용을 변경하고 '저장' 버튼 클릭
* 2. 수정 요청이 Business Logic 계층으로 전달 됨
* 3. 비즈니스 로직 계층에서 사용자 권한 확인, 입력값 검증 등의 비즈니스 규칙 적용
* 4. 검증 완료 후 데이터 계층에 수정 쿼리(Update SQL)를 요청
* 5. 데이터 계층이 데이터베이스에 해당 글을 수정하고 성공 여부를 비즈니스 로직 계층에 전달
* 6. 비즈니스 로직 계층이 수정 성공 여부를 받아 프레젠테이션 계층에 결과 전달
* 7. 프레젠테이션 계층에서 사용자에게 수정 결과 표시

3계층 구조와 CRUD 작동 흐름의 관계
1. **Create**
* Presentation: 
a. 사용자로부터 데이터를 입력받는 UI(예:회원가입, 게시글, 상품 등록)를 제공합니다.
b. 사용자가 폼을 통해 데이터를 입력하고 저장 또는 생성 버튼을 클릭하면, 해당 데이터를 비즈니스 로직 계층으로 전달합니다.
c. 간단한 클라이언트 측 유효성 검사(예:빈 값 확인)를 수행할 수 있습니다.
* Busienss Logic: 
a. 프레젠테이션 계층으로부터 받은 데이터에 대한 복잡한 비즈니스 규칙을 적용합니다.(예:사용자 이름 중복 확인, 게시글 내용 길이 제한, 상품가격 유효성 검사 등) 
b. 필요에 따라 다른 시스템과의 연동 로직을 수행할 수 있습니다.
c. 모든 비즈니스 규칙이 충족되면 데이터 접근 계층을 호출하여 데이터를 영구 저장소에 저장하도록 요청합니다.
d. 데이터 저장에 성공하면 프레젠테이션 계층에 성공 메시지를 반환합니다.
* DAL:
a. 비즈니스 로직 계층으로부터 받은 데이터를 데이터베이스의 테이블 또는 문서 구조에 맞게 변환합니다.
b. SQL의 Insert문(관계형 데이터베이스) 또는 NoSQL 데이터베이스의 삽입 연산을 사용하여 실제 데이터베이스에 새로운 레코드를 생성합니다.
c. 데이터베이스 작업 중 발생할 수 있는 오류(예:제약 조건 위반)를 처리하고 비즈니스 로직 계층으로 전달합니다.
2. **Read**
* Presentation:
a. 사용자가 데이터를 조회할 수 있는 UI(예:상품목록 페이지, 게시판, 마이페이지)를 제공합니다.
b. 사용자가 '검색', '상세보기', '목록보기' 등의 요청을 하면, 해당 요청을 비즈니스 로직 게층으로 전달합니다. (예:특정 ID의 상품 조회, 특정 키워드로 게시글 검색)
c. 비즈니스 로직 계층으로부터 받은 데이터를 사용자 친화적인 형태로 화면에 랜더링합니다.
* Business Logic:
a. 프레젠테이션 계층으로부터 받은 조회 요청을 처리합니다. (예 특정 사용자에게만 허용되는 정보인지 권한 확인, 검색 조건 가공)
b. 데이터 접근 계층을 호출하여 필요한 데이터를 조회하도록 요청합니다.
c. 데이터 접근 계층으로부터 받은 데이터를 비즈니스 로직에 맞게 가공하거나 필터링할 수 있습니다.
d. 가공된 데이터를 프레젠테이션 계층으로 변화합니다.
* DAL:
a. 비즈니스 로직 계층으로부터 받은 조회 요청에 따라 SQL의 Select문(관계형 데이터베니스) 또는 NoSQL 데이터베이스의 조회 연산을 사용하여 데이터베이스에서 데이터를 검색합니다.
b. 조회된 데이터를 객체 형태로 매핑하여 비즈니스 로직 게층으로 반환합니다.
3. **Update**
* Presentation:
a. 사용자가 기존 데이터를 수정할 수 있는 UI(예:회원 정보 수정 폼, 게시글 수정 폼)를 제공합니다.
b. 수정할 데이터를 조회하여 폼에 미리 채워 넣고, 사용자가 수정된 데이터를 입력한 후 '저장' 또는 '수정'버튼을 클릭하면, 수정된 데이터를 비즈니스 로직 계층으로 전달합니다.
* Business Logic:
a. 프레젠테이션 계층으로부터 받은 수정 데이터와 대상 레코드의 식별자를 기반으로 비즈니스 규칙을 적용합니다.(예:수정 권한 확인, 수정될 데이터의 유효성 검사)
b. 필요한 경우, 기존 데이터와 수정된 데이터를 비교하여 변경 이력을 관리할 수 있습니다.
c. 데이터 접근 계층을 호출하여 데이터 업데이트를 요청합니다.
d. 업데이트 성공 여부를 프레젠테이션 계층에 반환합니다.
* DAL:
a. 비즈니스 로직 계층으로부터 받은 수정 데이터를 기반으로 SQL의 Update문(관계형 데이터베이스) 또는 NoSQL 데이터베이스의 업데이트 연산을 사용하여 데이터베이스의 기존 레코드를 수정합니다.
b. 데이터베이스 작업 중 발생할 수 있는 오류를 처리하고 비즈니스 로직 계층으로 전달합니다.
4. **Delete**
* Presentation:
a. 사용자가 데이터를 삭제할 수 있는 UI(예:게시글 삭제 버튼, 회원 탈퇴 버튼)를 제공합니다.
b. 사용자가 '삭제'버튼을 클릭하면, 삭제를 레코드의 식별자를 비즈니스 로직 계층으로 전달합니다.
* Business Logic:
a. 프레젠테이션 계층으로부터 받은 삭제 요청에 대해 비즈니스 규칙을 적용합니다.(예:삭제 권한 확인, 관련 데이터 삭제 또는 논리적 삭제[status변경]처리 여부 결정)
b. 데이터 접근 계층을 호출하여 데이터 삭제를 요청합니다.
c. 삭제 성공 여부를 프레젠테이션 계층에 반환합니다.
* DAL:
a. 비즈니스 로직 계층으로부터 받은 식별자를 기반으로 SQL의 Delete문(관계형 데이터베이스) 또는 NoSQL 데이터베이스의 삭제 연산을 사용하여 데이터베이스에서 해당 레코드를 삭제합니다.
b. 데이터베이스 작업 중 발생할 수 있는 오류를 처리하고 비즈니스 로직 계층으로 전달합니다.